package HomeTask04_2;

// Используйте предыдущие задачи из прошлого домашнего задания. Необходимо гарантированно продумать
// иерархию компонент и взаимодействия их между собой.
// Обеспечить переход от использования явных классов в сторону использования абстрактных типов. Т е работаем не с:
// конкретным экземпляром генеалогического древа, а с интерфейсом “ генеалогическое древо”
// конкретным экземпляром котика, а с интерфейсом “котик”, лучше уйти от взаимодействия с конкретными питомцами
// и повысить уровень абстракции до взаимодействия с котиком, собачкой или хомяком т е с интерфейсом “животное”.
//
// Просыми словами : Минимум - Реализовать несколько интерфейсов в пред задаче

public class Task02 {
    public static void main(String[] args) {
        Husband h1 = new Husband("Brad", "husband");
        h1.about();
        Wife w1 = new Wife("Amy", "wife", false);
        w1.about();
        Cat c1 = new Cat("Barsik", "on wardrobe");
        c1.about();             // Кот на шкафу
//        h1.catCall(c1, h1);     // Брэд зовет кота
//        c1.about();             // Кот у Брэда
//        w1.catCall(c1, w1);     // Эми зовет кота
//        c1.about();             // Кот у Эми
        Furniture f1 = new Furniture("wardrobe", "closed");
        f1.about();
//        h1.wardOpen(w1, f1);    // Брэд хочет открыть шкаф (но нет разрешения от Эми)
//        w1.givePermit();        // Эми дает разрешение
//        h1.wardOpen(w1, f1);    // Брэд открывает шкаф
//        h1.wardClose(f1);       // Брэд закрывает шкаф
//        h1.wardOpen(w1, f1);    // Брэд открывает шкаф
//        h1.wardOpen(w1, f1);    // Брэд хочет открыть шкаф (но он уже открыт)
//        w1.wardClose(f1);       // Эми закрывает шкаф
        WifeCall<String> wCall = (caller, walker) -> {          //Лямбда выражение
            w1.setPlace(String.format("Near %s", caller));
            System.out.printf("%s called %s\n", caller, walker);
        };
        wCall.WifeCall(h1.getName(), w1.getName());
        w1.about();
    }
}
